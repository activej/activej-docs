(self.webpackChunkactivejdocs=self.webpackChunkactivejdocs||[]).push([[2275],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=l(n),m=a,v=u["".concat(c,".").concat(m)]||u[m]||d[m]||s;return n?r.createElement(v,i(i({ref:t},p),{},{components:n})):r.createElement(v,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var l=2;l<s;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},77618:function(e,t,n){"use strict";var r=n(67294),a=n(39962);t.Z=function(e){var t=e.url,n=e.text,s=e.isInline,i=void 0===s||s,o=e.children,c=(0,a.Z)().siteConfig;return r.createElement("a",{style:i?{}:{display:"block",marginBottom:"16px"},href:c.customFields.githubUrl+"/"+c.customFields.githubBranch+t,target:"_blank"},n||o)}},77815:function(e,t,n){"use strict";n(67294);var r=n(39962);t.Z=function(e){var t=e.name,n=(0,r.Z)().siteConfig;if(!t)throw new Error("Variable name is required");if(void 0===n.customFields[t])throw new Error("Variable "+t+" not exist");return n.customFields[t]}},87272:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return d},toc:function(){return u},default:function(){return v}});var r=n(22122),a=n(19756),s=(n(67294),n(3905)),i=n(77618),o=n(77815),c=["components"],l={description:"Lightning-fast binary protocol for microservices architecture",keywords:["java","java framework","tutorial","guide","memcached","rpc","client-server","web application","microservices"]},p="Basic Examples",d={unversionedId:"rpc/basic-examples",id:"rpc/basic-examples",isDocsHomePage:!1,title:"Basic Examples",description:"Lightning-fast binary protocol for microservices architecture",source:"@site/docs/rpc/basic-examples.mdx",sourceDirName:"rpc",slug:"/rpc/basic-examples",permalink:"/rpc/basic-examples",version:"current",frontMatter:{description:"Lightning-fast binary protocol for microservices architecture",keywords:["java","java framework","tutorial","guide","memcached","rpc","client-server","web application","microservices"]},sidebar:"docs",previous:{title:"ActiveJ RPC | Lightning-fast binary protocol for high-load architecture",permalink:"/rpc"},next:{title:"Key-Value Storage",permalink:"/rpc/key-value-storage"}},u=[{value:"Simple RPC Example",id:"simple-rpc-example",children:[]},{value:"Round-Robin Strategy",id:"round-robin-strategy",children:[]},{value:"Round-Robin and First Available Strategies Combined",id:"round-robin-and-first-available-strategies-combined",children:[]},{value:"Sharding and First Valid Strategies Combined",id:"sharding-and-first-valid-strategies-combined",children:[]},{value:"Rendezvous Hashing Strategy",id:"rendezvous-hashing-strategy",children:[]},{value:"Type Dispatch Strategy",id:"type-dispatch-strategy",children:[]}],m={toc:u};function v(e){var t=e.components,n=(0,a.Z)(e,c);return(0,s.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"basic-examples"},"Basic Examples"),(0,s.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"To run the examples, you need to clone ActiveJ from GitHub"),(0,s.kt)("pre",{parentName:"div"},(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"git clone https://github.com/activej/activej\n")),(0,s.kt)("p",{parentName:"div"},"And import it as a Maven project. Check out tag ",(0,s.kt)("strong",{parentName:"p"},(0,s.kt)(o.Z,{name:"currentVersion",mdxType:"Variable"})),". Before running the examples, build the project. ",(0,s.kt)("strong",{parentName:"p"},"Simple RPC Example")," are located at ",(0,s.kt)("inlineCode",{parentName:"p"},"activej/examples/cloud/rpc")),(0,s.kt)("p",{parentName:"div"},"RPC strategies examples are located at ",(0,s.kt)("inlineCode",{parentName:"p"},"activej/cloud-rpc/src/test/RpcStrategiesTest")))),(0,s.kt)("h2",{id:"simple-rpc-example"},"Simple RPC Example"),(0,s.kt)("p",null,'In the "Hello World" client and server ',(0,s.kt)("strong",{parentName:"p"},"RPC Example"),", the client sends a request which contains the word ",(0,s.kt)("inlineCode",{parentName:"p"},'"World"')," to server. When\nserver receives it, it sends a response that contains the word ",(0,s.kt)("inlineCode",{parentName:"p"},'"Hello "'),". If everything completes successfully, we get the\nfollowing output:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text"},"Got result: Hello World\n")),(0,s.kt)("p",null,"Let's take a look at the implementation:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"url=/examples/cloud/rpc/src/main/java/RpcExample.java tag=EXAMPLE",url:"/examples/cloud/rpc/src/main/java/RpcExample.java",tag:"EXAMPLE"},'public class RpcExample extends Launcher {\n  private static final int SERVICE_PORT = 34765;\n\n  @Inject\n  private RpcClient client;\n\n  @Inject\n  private RpcServer server;\n\n  @Inject\n  private Eventloop eventloop;\n\n  @Provides\n  Eventloop eventloop() {\n    return Eventloop.create();\n  }\n\n  @Provides\n  RpcServer rpcServer(Eventloop eventloop) {\n    return RpcServer.create(eventloop)\n        .withMessageTypes(String.class)\n        .withHandler(String.class,\n            request -> Promise.of("Hello " + request))\n        .withListenPort(SERVICE_PORT);\n  }\n\n  @Provides\n  RpcClient rpcClient(Eventloop eventloop) {\n    return RpcClient.create(eventloop)\n        .withMessageTypes(String.class)\n        .withStrategy(server(new InetSocketAddress(SERVICE_PORT)));\n  }\n\n  @ProvidesIntoSet\n  Initializer<ServiceGraphModuleSettings> configureServiceGraph() {\n    // add logical dependency so that service graph starts client only after it started the server\n    return settings -> settings.addDependency(Key.of(RpcClient.class), Key.of(RpcServer.class));\n  }\n\n  @Override\n  protected Module getModule() {\n    return ServiceGraphModule.create();\n  }\n\n  @Override\n  protected void run() throws ExecutionException, InterruptedException {\n    CompletableFuture<Object> future = eventloop.submit(() ->\n        client.sendRequest("World", 1000)\n    );\n    System.out.printf("%nRPC result: %s %n%n", future.get());\n  }\n\n  public static void main(String[] args) throws Exception {\n    RpcExample example = new RpcExample();\n    example.launch(args);\n  }\n}\n')),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"RpcExample")," class extends ",(0,s.kt)("a",{parentName:"p",href:"/boot/launcher"},"ActiveJ ",(0,s.kt)("inlineCode",{parentName:"a"},"Launcher"))," to help us manage application\nlifecycle."),(0,s.kt)("p",null,"Next, we use Dependency Injection library ",(0,s.kt)("a",{parentName:"p",href:"/inject"},"ActiveJ Inject")," to provide ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/server/RpcServer.java",mdxType:"Githublink"},(0,s.kt)("inlineCode",{parentName:"p"},"RpcServer"))," and ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/client/RpcClient.java",mdxType:"Githublink"},(0,s.kt)("inlineCode",{parentName:"p"},"RpcClient"))," with relevant configurations and required dependencies. ",(0,s.kt)("inlineCode",{parentName:"p"},"RpcClient")," sends requests with a String message to the specified server according to the provided ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategies.java",mdxType:"Githublink"},"RPC strategy")," (getting a single RPC-service).\nFor ",(0,s.kt)("inlineCode",{parentName:"p"},"RpcServer")," we define the type of messages to proceed, a corresponding ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/server/RpcRequestHandler.java",mdxType:"Githublink"},(0,s.kt)("inlineCode",{parentName:"p"},"RpcRequestHandler"))," and a listener port."),(0,s.kt)("p",null,"Since we extend ",(0,s.kt)("inlineCode",{parentName:"p"},"Launcher"),", we will also override 2 methods: ",(0,s.kt)("inlineCode",{parentName:"p"},"getModule")," to provide ",(0,s.kt)("a",{parentName:"p",href:"/boot/servicegraph"},(0,s.kt)("inlineCode",{parentName:"a"},"ServiceGraphModule"))," and ",(0,s.kt)("inlineCode",{parentName:"p"},"run")," to describe the main logic of the example."),(0,s.kt)("p",null,"Finally, we define the ",(0,s.kt)("inlineCode",{parentName:"p"},"main")," method, which will launch our example."),(0,s.kt)("p",null,"You can find example sources on ",(0,s.kt)(i.Z,{url:"/examples/cloud/rpc/src/main/java/RpcExample.java",mdxType:"Githublink"},(0,s.kt)("strong",{parentName:"p"},"GitHub"))),(0,s.kt)("h2",{id:"round-robin-strategy"},"Round-Robin Strategy"),(0,s.kt)("p",null,"ActiveJ RPC contains pre-defined strategies for requests arrangement between RPC servers or shards of servers. ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyRoundRobin.java",mdxType:"Githublink"},"Round-Robin")," is one of the simplest of strategies: it just goes through the servers or shards in a cyclic way one by one."),(0,s.kt)("p",null,"In this example we create an RPC ",(0,s.kt)("em",{parentName:"p"},"pool")," with 5 equal ",(0,s.kt)("em",{parentName:"p"},"connections")," and set Round-Robin strategy for them. Next, we create a sender for the pool with the previously defined strategy. That's it, 100 requests will be equally distributed between the servers:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_1",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_1"},"public void roundRobinTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  int iterations = 100;\n  RpcStrategy strategy = roundRobin(servers(address1, address2, address3, address4, address5));\n\n  RpcSender sender = strategy.createSender(pool);\n  for (int i = 0; i < iterations; i++) {\n    sender.sendRequest(new Object(), 50, ignore());\n  }\n\n  List<RpcSenderStub> connections =\n      asList(connection1, connection2, connection3, connection4, connection5);\n  for (int i = 0; i < 5; i++) {\n    assertEquals(iterations / 5, connections.get(i).getRequests());\n  }\n}\n")),(0,s.kt)("p",null,"You can find example sources on ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L32",mdxType:"Githublink"},(0,s.kt)("strong",{parentName:"p"},"GitHub"))),(0,s.kt)("h2",{id:"round-robin-and-first-available-strategies-combined"},"Round-Robin and First Available Strategies Combined"),(0,s.kt)("p",null,"You can simply combine RPC strategies. In this example we will combine ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyRoundRobin.java",mdxType:"Githublink"},"Round Robin")," and ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyFirstAvailable.java",mdxType:"Githublink"},"First Available")," strategies."),(0,s.kt)("p",null,"First, we create 4 connections without putting ",(0,s.kt)("em",{parentName:"p"},"connection3")," into the pool. Then we start sending 20 requests.\nAs a result, all the requests will be equally distributed between ",(0,s.kt)("em",{parentName:"p"},"connection1")," (as it is always ",(0,s.kt)("em",{parentName:"p"},"first available"),") and\n",(0,s.kt)("em",{parentName:"p"},"connection4")," (as ",(0,s.kt)("em",{parentName:"p"},"connection3")," isn't available for the pool):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_2",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_2"},"public void roundRobinAndFirstAvailableTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  // we don't put connection3\n  pool.put(address4, connection4);\n  int iterations = 20;\n  RpcStrategy strategy = roundRobin(\n      firstAvailable(servers(address1, address2)),\n      firstAvailable(servers(address3, address4)));\n\n  RpcSender sender = strategy.createSender(pool);\n  for (int i = 0; i < iterations; i++) {\n    sender.sendRequest(new Object(), 50, assertNoCalls());\n  }\n\n  assertEquals(iterations / 2, connection1.getRequests());\n  assertEquals(0, connection2.getRequests());\n  assertEquals(0, connection3.getRequests());\n  assertEquals(iterations / 2, connection4.getRequests());\n}\n")),(0,s.kt)("p",null,"You can find example sources on ",(0,s.kt)(i.Z,{text:"GitHub",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L62",mdxType:"Githublink"})),(0,s.kt)("h2",{id:"sharding-and-first-valid-strategies-combined"},"Sharding and First Valid Strategies Combined"),(0,s.kt)("p",null,"You can also create your own sharding functions and combine them with other strategies if needed. In this example we create 5 equal connections but don't put ",(0,s.kt)("em",{parentName:"p"},"connection2")," into the pool. Next, we provide a simple sharding function which distributes requests between shards in accordance to the content of the request. We split the connections into two shards, and set ",(0,s.kt)(i.Z,{text:"First Valid Result",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyFirstValidResult.java",mdxType:"Githublink"})," strategy for both of them. This strategy sends request to all available servers."),(0,s.kt)("p",null,"Now, we manually send 7 requests:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"4 with ",(0,s.kt)("inlineCode",{parentName:"li"},"0")," message, so they'll be sent to the first shard's ",(0,s.kt)("em",{parentName:"li"},"connection1")),(0,s.kt)("li",{parentName:"ul"},"3 with ",(0,s.kt)("inlineCode",{parentName:"li"},"1"),", so they'll all be sent to all three connections of the second shard")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_3",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_3"},"public void shardingAndFirstValidTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  // we don't put connection2\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  int shardsCount = 2;\n  ShardingFunction<Integer> shardingFunction = item -> item % shardsCount;\n  RpcStrategy strategy = sharding(shardingFunction,\n      firstValidResult(servers(address1, address2)),\n      firstValidResult(servers(address3, address4, address5)));\n\n  RpcSender sender = strategy.createSender(pool);\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(1, 50, assertNoCalls());\n  sender.sendRequest(1, 50, assertNoCalls());\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(1, 50, assertNoCalls());\n\n  assertEquals(4, connection1.getRequests());\n  assertEquals(0, connection2.getRequests());\n  assertEquals(3, connection3.getRequests());\n  assertEquals(3, connection4.getRequests());\n  assertEquals(3, connection5.getRequests());\n}\n")),(0,s.kt)("p",null,"You can find example sources on ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L91",mdxType:"Githublink"},(0,s.kt)("strong",{parentName:"p"},"GitHub"))),(0,s.kt)("h2",{id:"rendezvous-hashing-strategy"},"Rendezvous Hashing Strategy"),(0,s.kt)("p",null,"Rendezvous hashing strategy pre-calculates the hash function for the ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcSender.java",mdxType:"Githublink"},(0,s.kt)("inlineCode",{parentName:"p"},"RpcSender"))," and creates a map of RPC servers. The map is stored in cache and will be re-calculated only if servers go online/offline."),(0,s.kt)("p",null,"In this example requests will be equally distributed between ",(0,s.kt)("em",{parentName:"p"},"connection1"),", ",(0,s.kt)("em",{parentName:"p"},"connection2"),", and ",(0,s.kt)("em",{parentName:"p"},"connection3"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_4",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_4"},"public void rendezvousHashingTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  HashFunction<Integer> hashFunction = item -> item;\n  RpcStrategy strategy = rendezvousHashing(hashFunction)\n      .withShard(1, firstAvailable(servers(address1, address2)))\n      .withShard(2, firstAvailable(servers(address3, address4)))\n      .withShard(3, server(address5));\n  int iterationsPerLoop = 1000;\n  RpcSender sender;\n\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  sender = strategy.createSender(pool);\n  for (int i = 0; i < iterationsPerLoop; i++) {\n    sender.sendRequest(i, 50, ignore());\n  }\n")),(0,s.kt)("p",null,"When we remove some of the connections from the pool, hash function is recalculated:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_5",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_5"},"  pool.remove(address3);\n  pool.remove(address4);\n  sender = strategy.createSender(pool);\n  for (int i = 0; i < iterationsPerLoop; i++) {\n    sender.sendRequest(i, 50, ignore());\n  }\n\n  double acceptableError = iterationsPerLoop / 10.0;\n  assertEquals(iterationsPerLoop / 3.0 + iterationsPerLoop / 2.0, connection1.getRequests(), acceptableError);\n  assertEquals(0, connection2.getRequests());\n  assertEquals(iterationsPerLoop / 3.0, connection3.getRequests(), acceptableError);\n  assertEquals(0, connection4.getRequests());\n  assertEquals(iterationsPerLoop / 3.0 + iterationsPerLoop / 2.0, connection5.getRequests(), acceptableError);\n}\n")),(0,s.kt)("p",null,"You can find example sources on ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L128",mdxType:"Githublink"},(0,s.kt)("strong",{parentName:"p"},"GitHub"))),(0,s.kt)("h2",{id:"type-dispatch-strategy"},"Type Dispatch Strategy"),(0,s.kt)("p",null,"This strategy simply distributes requests among shards in accordance to the type of the request. In the example\nall ",(0,s.kt)("strong",{parentName:"p"},"String")," requests are sent on the first shard which has ",(0,s.kt)("em",{parentName:"p"},"First Valid Result")," strategy for the servers. Requests\nwith all other types are sent to the second shard with ",(0,s.kt)("em",{parentName:"p"},"First Available")," strategy. As a result, ",(0,s.kt)("em",{parentName:"p"},"connection1")," and\n",(0,s.kt)("em",{parentName:"p"},"connection2")," will process 35 requests, ",(0,s.kt)("em",{parentName:"p"},"connection3")," - 25 requests, while ",(0,s.kt)("em",{parentName:"p"},"connection4")," and ",(0,s.kt)("em",{parentName:"p"},"connection5")," - 0 requests\nas ",(0,s.kt)("em",{parentName:"p"},"connection3")," was always ",(0,s.kt)("em",{parentName:"p"},"First Available"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_6",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_6"},'public void typeDispatchTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  int timeout = 50;\n  int iterationsPerDataStub = 25;\n  int iterationsPerDataStubWithKey = 35;\n  RpcSender sender;\n  RpcStrategy strategy = typeDispatching()\n      .on(String.class,\n          firstValidResult(servers(address1, address2)))\n      .onDefault(\n          firstAvailable(servers(address3, address4, address5)));\n\n  sender = strategy.createSender(pool);\n  for (int i = 0; i < iterationsPerDataStub; i++) {\n    sender.sendRequest(new Object(), timeout, assertNoCalls());\n  }\n  for (int i = 0; i < iterationsPerDataStubWithKey; i++) {\n    sender.sendRequest("request", timeout, assertNoCalls());\n  }\n\n  assertEquals(iterationsPerDataStubWithKey, connection1.getRequests());\n  assertEquals(iterationsPerDataStubWithKey, connection2.getRequests());\n  assertEquals(iterationsPerDataStub, connection3.getRequests());\n  assertEquals(0, connection4.getRequests());\n  assertEquals(0, connection5.getRequests());\n}\n')),(0,s.kt)("p",null,"You can find example sources on ",(0,s.kt)(i.Z,{url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L172",mdxType:"Githublink"},(0,s.kt)("strong",{parentName:"p"},"GitHub"))))}v.isMDXComponent=!0}}]);