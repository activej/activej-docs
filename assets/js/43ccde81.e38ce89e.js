(self.webpackChunkactivejdocs=self.webpackChunkactivejdocs||[]).push([[2275],{3905:function(e,n,t){"use strict";t.r(n),t.d(n,{MDXContext:function(){return d},MDXProvider:function(){return u},mdx:function(){return g},useMDXComponents:function(){return p},withMDXComponents:function(){return l}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(){return(s=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=r.createContext({}),l=function(e){return function(n){var t=p(n.components);return r.createElement(e,s({},n,{components:t}))}},p=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(d.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},v=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),l=p(t),u=a,v=l["".concat(i,".").concat(u)]||l[u]||m[u]||s;return t?r.createElement(v,o(o({ref:n},d),{},{components:t})):r.createElement(v,o({ref:n},d))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,i=new Array(s);i[0]=v;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var d=2;d<s;d++)i[d]=t[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}v.displayName="MDXCreateElement"},77618:function(e,n,t){"use strict";var r=t(95318).default;n.Z=void 0;var a=r(t(67294)),s=r(t(39962)),i=function(e){var n=e.url,t=e.text,r=e.isInline,i=void 0===r||r,o=e.children,c=(0,s.default)().siteConfig;return a.default.createElement("a",{style:i?{}:{display:"block",marginBottom:"16px"},href:c.customFields.githubUrl+"/"+c.customFields.githubBranch+n,target:"_blank"},a.default.createElement("b",null,t||o))};n.Z=i},77815:function(e,n,t){"use strict";var r=t(95318).default;n.Z=void 0;r(t(67294));var a=r(t(39962)),s=function(e){var n=e.name,t=(0,a.default)().siteConfig;if(!n)throw new Error("Variable name is required");if(void 0===t.customFields[n])throw new Error("Variable "+n+" not exist");return t.customFields[n]};n.Z=s},87272:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return d},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var r=t(22122),a=t(19756),s=(t(67294),t(3905)),i=t(77618),o=t(77815),c=["components"],d={description:"Lightning-fast binary protocol for microservices architecture",keywords:"java,java framework,tutorial,guide,memcached,rpc,client-server,web application,microservices"},l={unversionedId:"rpc/basic-examples",id:"rpc/basic-examples",isDocsHomePage:!1,title:"Basic Examples",description:"Lightning-fast binary protocol for microservices architecture",source:"@site/docs/rpc/basic-examples.mdx",sourceDirName:"rpc",slug:"/rpc/basic-examples",permalink:"/docs/rpc/basic-examples",version:"current",frontMatter:{description:"Lightning-fast binary protocol for microservices architecture",keywords:"java,java framework,tutorial,guide,memcached,rpc,client-server,web application,microservices"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/rpc/overview"},next:{title:"Key-Value Storage",permalink:"/docs/rpc/key-value-storage"}},p=[{value:"Simple RPC Example",id:"simple-rpc-example",children:[]},{value:"Round-Robin Strategy",id:"round-robin-strategy",children:[]},{value:"Round-Robin and First Available Strategies Combined",id:"round-robin-and-first-available-strategies-combined",children:[]},{value:"Sharding and First Valid Strategies Combined",id:"sharding-and-first-valid-strategies-combined",children:[]},{value:"Rendezvous Hashing Strategy",id:"rendezvous-hashing-strategy",children:[]},{value:"Type Dispatch Strategy",id:"type-dispatch-strategy",children:[]}],u={toc:p};function m(e){var n=e.components,t=(0,a.default)(e,c);return(0,s.mdx)("wrapper",(0,r.default)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,s.mdx)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.mdx)("div",{parentName:"div",className:"admonition-heading"},(0,s.mdx)("h5",{parentName:"div"},(0,s.mdx)("span",{parentName:"h5",className:"admonition-icon"},(0,s.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.mdx)("div",{parentName:"div",className:"admonition-content"},(0,s.mdx)("p",{parentName:"div"},"To run the examples, you need to clone ActiveJ from GitHub"),(0,s.mdx)("pre",{parentName:"div"},(0,s.mdx)("code",{parentName:"pre",className:"language-shell"},"git clone https://github.com/activej/activej\n")),(0,s.mdx)("p",{parentName:"div"},"And import it as a Maven project. Check out tag ",(0,s.mdx)("strong",{parentName:"p"},(0,s.mdx)(o.Z,{name:"currentVersion",mdxType:"Variable"})),". Before running the examples, build the project. ",(0,s.mdx)("strong",{parentName:"p"},"Simple RPC Example")," are located at ",(0,s.mdx)("inlineCode",{parentName:"p"},"activej/examples/cloud/rpc")),(0,s.mdx)("p",{parentName:"div"},"RPC strategies examples are located at ",(0,s.mdx)("inlineCode",{parentName:"p"},"activej/cloud-rpc/src/test/RpcStrategiesTest")))),(0,s.mdx)("h2",{id:"simple-rpc-example"},"Simple RPC Example"),(0,s.mdx)("p",null,'In the "Hello World" client and server ',(0,s.mdx)("strong",{parentName:"p"},"RPC Example"),", the client sends a request which contains the word ",(0,s.mdx)("inlineCode",{parentName:"p"},'"World"')," to server. When\nserver receives it, it sends a response that contains the word ",(0,s.mdx)("inlineCode",{parentName:"p"},'"Hello "'),". If everything completes successfully, we get the\nfollowing output:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-text"},"Got result: Hello World\n")),(0,s.mdx)("p",null,"Let's take a look at the implementation:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java",metastring:"url=/examples/cloud/rpc/src/main/java/RpcExample.java tag=EXAMPLE",url:"/examples/cloud/rpc/src/main/java/RpcExample.java",tag:"EXAMPLE"},'public class RpcExample extends Launcher {\n  private static final int SERVICE_PORT = 34765;\n\n  @Inject\n  private RpcClient client;\n\n  @Inject\n  private RpcServer server;\n\n  @Inject\n  private Eventloop eventloop;\n\n  @Provides\n  Eventloop eventloop() {\n    return Eventloop.create();\n  }\n\n  @Provides\n  RpcServer rpcServer(Eventloop eventloop) {\n    return RpcServer.create(eventloop)\n        .withMessageTypes(String.class)\n        .withHandler(String.class,\n            request -> Promise.of("Hello " + request))\n        .withListenPort(SERVICE_PORT);\n  }\n\n  @Provides\n  RpcClient rpcClient(Eventloop eventloop) {\n    return RpcClient.create(eventloop)\n        .withMessageTypes(String.class)\n        .withStrategy(server(new InetSocketAddress(SERVICE_PORT)));\n  }\n\n  @ProvidesIntoSet\n  Initializer<ServiceGraphModuleSettings> configureServiceGraph() {\n    // add logical dependency so that service graph starts client only after it started the server\n    return settings -> settings.addDependency(Key.of(RpcClient.class), Key.of(RpcServer.class));\n  }\n\n  @Override\n  protected Module getModule() {\n    return ServiceGraphModule.create();\n  }\n\n  @Override\n  protected void run() throws ExecutionException, InterruptedException {\n    CompletableFuture<Object> future = eventloop.submit(() ->\n        client.sendRequest("World", 1000)\n    );\n    System.out.printf("%nRPC result: %s %n%n", future.get());\n  }\n\n  public static void main(String[] args) throws Exception {\n    RpcExample example = new RpcExample();\n    example.launch(args);\n  }\n}\n')),(0,s.mdx)("p",null,(0,s.mdx)("inlineCode",{parentName:"p"},"RpcExample")," class extends ",(0,s.mdx)("a",{parentName:"p",href:"/docs/boot/launcher"},"ActiveJ ",(0,s.mdx)("strong",{parentName:"a"},"Launcher"))," to help us manage application\nlifecycle."),(0,s.mdx)("p",null,"Next, we use Dependency Injection library ",(0,s.mdx)("a",{parentName:"p",href:"/docs/inject/overview"},"ActiveJ Inject")," to provide ",(0,s.mdx)(i.Z,{text:"RpcServer",url:"/cloud-rpc/src/main/java/io/activej/rpc/server/RpcServer.java",mdxType:"Githublink"})," and ",(0,s.mdx)(i.Z,{text:"RpcClient",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/RpcClient.java",mdxType:"Githublink"})," with relevant configurations and required dependencies. ",(0,s.mdx)("strong",{parentName:"p"},"RpcClient")," sends requests with a String message to the specified server according to the provided ",(0,s.mdx)(i.Z,{text:"RPC strategy",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategies.java",mdxType:"Githublink"})," (getting a single RPC-service).\nFor ",(0,s.mdx)("strong",{parentName:"p"},"RpcServer")," we define the type of messages to proceed, a corresponding ",(0,s.mdx)(i.Z,{text:"RpcRequestHandler",url:"/cloud-rpc/src/main/java/io/activej/rpc/server/RpcRequestHandler.java",mdxType:"Githublink"})," and a listener port."),(0,s.mdx)("p",null,"Since we extend ",(0,s.mdx)("strong",{parentName:"p"},"Launcher"),", we will also override 2 methods: ",(0,s.mdx)("em",{parentName:"p"},"getModule")," to provide ",(0,s.mdx)("a",{parentName:"p",href:"/docs/boot/servicegraph"},(0,s.mdx)("strong",{parentName:"a"},"ServiceGraphModule")),"\nand ",(0,s.mdx)("em",{parentName:"p"},"run")," to describe the main logic of the example."),(0,s.mdx)("p",null,"Finally, we define the ",(0,s.mdx)("inlineCode",{parentName:"p"},"main")," method, which will launch our example."),(0,s.mdx)("p",null,"You can find example sources on ",(0,s.mdx)(i.Z,{text:"GitHub",url:"/examples/cloud/rpc/src/main/java/RpcExample.java",mdxType:"Githublink"})),(0,s.mdx)("h2",{id:"round-robin-strategy"},"Round-Robin Strategy"),(0,s.mdx)("p",null,"ActiveJ RPC contains pre-defined strategies for requests arrangement between RPC servers or shards of servers. ",(0,s.mdx)(i.Z,{text:"Round-Robin",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyRoundRobin.java",mdxType:"Githublink"})," is one of the simplest of strategies: it just goes through the servers or shards in a cyclic way one by one."),(0,s.mdx)("p",null,"In this example we create an RPC ",(0,s.mdx)("em",{parentName:"p"},"pool")," with 5 equal ",(0,s.mdx)("em",{parentName:"p"},"connections")," and set Round-Robin\nstrategy for them. Next, we create a sender for the pool with the previously defined strategy. That's it, 100\nrequests will be equally distributed between the servers:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_1",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_1"},"public void roundRobinTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  int iterations = 100;\n  RpcStrategy strategy = roundRobin(servers(address1, address2, address3, address4, address5));\n\n  RpcSender sender = strategy.createSender(pool);\n  for (int i = 0; i < iterations; i++) {\n    sender.sendRequest(new Object(), 50, ignore());\n  }\n\n  List<RpcSenderStub> connections =\n      asList(connection1, connection2, connection3, connection4, connection5);\n  for (int i = 0; i < 5; i++) {\n    assertEquals(iterations / 5, connections.get(i).getRequests());\n  }\n}\n")),(0,s.mdx)("p",null,"You can find example sources on ",(0,s.mdx)(i.Z,{text:"GitHub",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L32",mdxType:"Githublink"})),(0,s.mdx)("h2",{id:"round-robin-and-first-available-strategies-combined"},"Round-Robin and First Available Strategies Combined"),(0,s.mdx)("p",null,"You can simply combine RPC strategies. In this example we will combine ",(0,s.mdx)(i.Z,{text:"Round Robin",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyRoundRobin.java",mdxType:"Githublink"})," and ",(0,s.mdx)(i.Z,{text:"First Available",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyFirstAvailable.java",mdxType:"Githublink"})," strategies."),(0,s.mdx)("p",null,"First, we create 4 connections without putting ",(0,s.mdx)("em",{parentName:"p"},"connection3")," into the pool. Then we start sending 20 requests.\nAs a result, all the requests will be equally distributed between ",(0,s.mdx)("em",{parentName:"p"},"connection1")," (as it is always ",(0,s.mdx)("em",{parentName:"p"},"first available"),") and\n",(0,s.mdx)("em",{parentName:"p"},"connection4")," (as ",(0,s.mdx)("em",{parentName:"p"},"connection3")," isn't available for the pool):"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_2",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_2"},"public void roundRobinAndFirstAvailableTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  // we don't put connection3\n  pool.put(address4, connection4);\n  int iterations = 20;\n  RpcStrategy strategy = roundRobin(\n      firstAvailable(servers(address1, address2)),\n      firstAvailable(servers(address3, address4)));\n\n  RpcSender sender = strategy.createSender(pool);\n  for (int i = 0; i < iterations; i++) {\n    sender.sendRequest(new Object(), 50, assertNoCalls());\n  }\n\n  assertEquals(iterations / 2, connection1.getRequests());\n  assertEquals(0, connection2.getRequests());\n  assertEquals(0, connection3.getRequests());\n  assertEquals(iterations / 2, connection4.getRequests());\n}\n")),(0,s.mdx)("p",null,"You can find example sources on ",(0,s.mdx)(i.Z,{text:"GitHub",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L62",mdxType:"Githublink"})),(0,s.mdx)("h2",{id:"sharding-and-first-valid-strategies-combined"},"Sharding and First Valid Strategies Combined"),(0,s.mdx)("p",null,"You can also create your own sharding functions and combine them with other strategies if needed. In this example we create 5 equal connections but don't put ",(0,s.mdx)("em",{parentName:"p"},"connection2")," into the pool. Next, we provide a simple sharding function which distributes requests between shards in accordance to the content of the request. We split the connections into two shards, and set ",(0,s.mdx)(i.Z,{text:"First Valid Result",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcStrategyFirstValidResult.java",mdxType:"Githublink"})," strategy for both of them. This strategy sends request to all available servers."),(0,s.mdx)("p",null,"Now, we manually send 7 requests:"),(0,s.mdx)("ul",null,(0,s.mdx)("li",{parentName:"ul"},"4 with ",(0,s.mdx)("inlineCode",{parentName:"li"},"0")," message, so they'll be sent to the first shard's ",(0,s.mdx)("em",{parentName:"li"},"connection1")),(0,s.mdx)("li",{parentName:"ul"},"3 with ",(0,s.mdx)("inlineCode",{parentName:"li"},"1"),", so they'll all be sent to all three connections of the second shard")),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_3",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_3"},"public void shardingAndFirstValidTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  // we don't put connection2\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  int shardsCount = 2;\n  ShardingFunction<Integer> shardingFunction = item -> item % shardsCount;\n  RpcStrategy strategy = sharding(shardingFunction,\n      firstValidResult(servers(address1, address2)),\n      firstValidResult(servers(address3, address4, address5)));\n\n  RpcSender sender = strategy.createSender(pool);\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(1, 50, assertNoCalls());\n  sender.sendRequest(1, 50, assertNoCalls());\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(0, 50, assertNoCalls());\n  sender.sendRequest(1, 50, assertNoCalls());\n\n  assertEquals(4, connection1.getRequests());\n  assertEquals(0, connection2.getRequests());\n  assertEquals(3, connection3.getRequests());\n  assertEquals(3, connection4.getRequests());\n  assertEquals(3, connection5.getRequests());\n}\n")),(0,s.mdx)("p",null,"You can find example sources on ",(0,s.mdx)(i.Z,{text:"GitHub",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L91",mdxType:"Githublink"})),(0,s.mdx)("h2",{id:"rendezvous-hashing-strategy"},"Rendezvous Hashing Strategy"),(0,s.mdx)("p",null,"Rendezvous hashing strategy pre-calculates the hash function for the ",(0,s.mdx)(i.Z,{text:"RpcSender",url:"/cloud-rpc/src/main/java/io/activej/rpc/client/sender/RpcSender.java",mdxType:"Githublink"})," and creates a map of RPC servers. The map is stored in cache and will be re-calculated only if servers go online/offline."),(0,s.mdx)("p",null,"In this example requests will be equally distributed between ",(0,s.mdx)("em",{parentName:"p"},"connection1"),", ",(0,s.mdx)("em",{parentName:"p"},"connection2"),", and ",(0,s.mdx)("em",{parentName:"p"},"connection3"),":"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_4",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_4"},"public void rendezvousHashingTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  HashFunction<Integer> hashFunction = item -> item;\n  RpcStrategy strategy = rendezvousHashing(hashFunction)\n      .withShard(1, firstAvailable(servers(address1, address2)))\n      .withShard(2, firstAvailable(servers(address3, address4)))\n      .withShard(3, server(address5));\n  int iterationsPerLoop = 1000;\n  RpcSender sender;\n\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  sender = strategy.createSender(pool);\n  for (int i = 0; i < iterationsPerLoop; i++) {\n    sender.sendRequest(i, 50, ignore());\n  }\n")),(0,s.mdx)("p",null,"When we remove some of the connections from the pool, hash function is recalculated:"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_5",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_5"},"  pool.remove(address3);\n  pool.remove(address4);\n  sender = strategy.createSender(pool);\n  for (int i = 0; i < iterationsPerLoop; i++) {\n    sender.sendRequest(i, 50, ignore());\n  }\n\n  double acceptableError = iterationsPerLoop / 10.0;\n  assertEquals(iterationsPerLoop / 3.0 + iterationsPerLoop / 2.0, connection1.getRequests(), acceptableError);\n  assertEquals(0, connection2.getRequests());\n  assertEquals(iterationsPerLoop / 3.0, connection3.getRequests(), acceptableError);\n  assertEquals(0, connection4.getRequests());\n  assertEquals(iterationsPerLoop / 3.0 + iterationsPerLoop / 2.0, connection5.getRequests(), acceptableError);\n}\n")),(0,s.mdx)("p",null,"You can find example sources on ",(0,s.mdx)(i.Z,{text:"GitHub",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L128",mdxType:"Githublink"})),(0,s.mdx)("h2",{id:"type-dispatch-strategy"},"Type Dispatch Strategy"),(0,s.mdx)("p",null,"This strategy simply distributes requests among shards in accordance to the type of the request. In the example\nall ",(0,s.mdx)("strong",{parentName:"p"},"String")," requests are sent on the first shard which has ",(0,s.mdx)("em",{parentName:"p"},"First Valid Result")," strategy for the servers. Requests\nwith all other types are sent to the second shard with ",(0,s.mdx)("em",{parentName:"p"},"First Available")," strategy. As a result, ",(0,s.mdx)("em",{parentName:"p"},"connection1")," and\n",(0,s.mdx)("em",{parentName:"p"},"connection2")," will process 35 requests, ",(0,s.mdx)("em",{parentName:"p"},"connection3")," - 25 requests, while ",(0,s.mdx)("em",{parentName:"p"},"connection4")," and ",(0,s.mdx)("em",{parentName:"p"},"connection5")," - 0 requests\nas ",(0,s.mdx)("em",{parentName:"p"},"connection3")," was always ",(0,s.mdx)("em",{parentName:"p"},"First Available"),":"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-java",metastring:"url=/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java tag=REGION_6",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java",tag:"REGION_6"},'public void typeDispatchTest() {\n  RpcClientConnectionPoolStub pool = new RpcClientConnectionPoolStub();\n  RpcSenderStub connection1 = new RpcSenderStub();\n  RpcSenderStub connection2 = new RpcSenderStub();\n  RpcSenderStub connection3 = new RpcSenderStub();\n  RpcSenderStub connection4 = new RpcSenderStub();\n  RpcSenderStub connection5 = new RpcSenderStub();\n  pool.put(address1, connection1);\n  pool.put(address2, connection2);\n  pool.put(address3, connection3);\n  pool.put(address4, connection4);\n  pool.put(address5, connection5);\n  int timeout = 50;\n  int iterationsPerDataStub = 25;\n  int iterationsPerDataStubWithKey = 35;\n  RpcSender sender;\n  RpcStrategy strategy = typeDispatching()\n      .on(String.class,\n          firstValidResult(servers(address1, address2)))\n      .onDefault(\n          firstAvailable(servers(address3, address4, address5)));\n\n  sender = strategy.createSender(pool);\n  for (int i = 0; i < iterationsPerDataStub; i++) {\n    sender.sendRequest(new Object(), timeout, assertNoCalls());\n  }\n  for (int i = 0; i < iterationsPerDataStubWithKey; i++) {\n    sender.sendRequest("request", timeout, assertNoCalls());\n  }\n\n  assertEquals(iterationsPerDataStubWithKey, connection1.getRequests());\n  assertEquals(iterationsPerDataStubWithKey, connection2.getRequests());\n  assertEquals(iterationsPerDataStub, connection3.getRequests());\n  assertEquals(0, connection4.getRequests());\n  assertEquals(0, connection5.getRequests());\n}\n')),(0,s.mdx)("p",null,"You can find example sources on ",(0,s.mdx)(i.Z,{text:"GitHub",url:"/cloud-rpc/src/test/java/io/activej/rpc/client/sender/RpcStrategiesTest.java#L172",mdxType:"Githublink"})))}m.isMDXComponent=!0}}]);